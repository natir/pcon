initSidebarItems({"constant":[["MIN_SCORE","Value to use as a 'negative infinity' score. Should be close to i32::MIN, but avoid underflow when used with reasonable scoring parameters or even adding two negative infinities. Use ~ 0.4 * i32::MIN"]],"mod":[["banded","Banded Smith-Waterman alignment for fast comparison of long strings. Use sparse dynamic programming to find a 'backbone' alignment from exact k-mer matches, then compute the SW alignment in a 'band' surrounding the backbone, with a configurable width w. This method is not guaranteed to recover the Smith-Waterman alignment, but will usually find the same alignment if a) there is a reasonable density of exact k-mer matches between the sequences, and b) the width parameter w is larger than the excursion of the alignment path from diagonal between successive kmer matches.  This technique is employed in long-read aligners (e.g. BLASR and BWA) to drastically reduce runtime compared to Smith Waterman. Complexity roughly O(min(m,n) * w)"]],"struct":[["Aligner","A generalized Smith-Waterman aligner."],["MatchParams","A concrete data structure which implements trait MatchFunc with constant match and mismatch scores"],["Scoring","Details of scoring are encapsulated in this structure. An affine gap score model is used so that the gap score for a length 'k' is: GapScore(k) = gap_open + gap_extend * k"],["TracebackCell","Packed representation of one cell of a Smith-Waterman traceback matrix. Stores the I, D and S traceback matrix values in two bytes. Possible traceback moves include : start, insert, delete, match, substitute, prefix clip and suffix clip for x & y. So we need 4 bits each for matrices I, D, S to keep track of these 9 moves."]],"trait":[["MatchFunc","Trait required to instantiate a Scoring instance"]]});